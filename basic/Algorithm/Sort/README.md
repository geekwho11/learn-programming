## 排序算法

### 冒泡排序

#### 背景知识

#### 实现思路
1. 采用2个指针，循环对比两个数的大小。
2. 注意循环的结束，条件，外层结束条件是数组的个数。
3. 内层循环 可以从前或者后面进行对比，重点，遇到小的元素，交换位置，移动到前面的位置。

#### [代码实现](./BubbleSort.php)

##### 方案1
1. 外层循环，倒序循环，到第一个元素结束。
2. 内层的循环，前后两个元素对比，最小的数，移动到最前面的位置。

##### 方案2
1. 外层循环，从第一个元素开始计算
2. 内层倒序开始循环，从最后一个元素开始对比，如果比前一个元素小，就交换位置。

#### 性能分析

1. 时间复杂度为O(n^2)，其中n为元素的个数
2. 最好情况时间复杂度为O(n)，刚好数组已排序。
3. 最坏情况时间复杂度为O(n^2)

### 快速排序

#### 背景知识

#### 实现思路
1. 主要采用2分法实现。

#### [代码实现](./QuickSort.php)

##### 方案1
1. 注意循环结束条件
2. 快排的主要思想就是2分法，取一个中间值，将比中间值大和小的值分组。
3. 然后递归调用，直到触发循环结束条件。

#### 性能分析

1. 时间复杂度为O(nlogn)，其中n为元素的个数
2. 最好情况时间复杂度为O(logn)，每次都恰好五五分。
3. 最坏情况时间复杂度为O(n^2),可能情况是一边是一个，一边是n-1个，即一个已经排好序的数组。

#### 参考链接
1. [如何证明快速排序法的平均复杂度为 O(nlogn)](https://www.zhihu.com/question/22393997)

### 选择排序

#### 背景知识

#### 实现思路
1. 在未排序的数组里，指定第一个元素，循环找到比这个数小的，交换位置。
2. 然后再在剩下的元素继续寻找最小的数，放在当前已排序的末尾。

#### [代码实现](./SelectSort.php)

##### 方案1
1. 外层循环
2. 内层循环，以第一个数为标准。
3. 找到比第一个还小的数，进行交换。

#### 性能分析

1. 最坏时间复杂度 О(n²)
2. 最优时间复杂度 О(n²)
3. 平均时间复杂度 О(n²)
4. 最坏空间复杂度 О(n) total, O(1) auxiliary

### 归并排序

#### 背景知识

#### 实现思路
1. 针对已排序的两个数组进行排序的算法。

#### [代码实现](./MergeSort.php)

##### 方案1
采用2层循环遍历，实现两个已排序的数组合并为一个排序数组。
1. 第一层循环，从一个元素开始到最后一个元素为止。
2. 选择每次循环的第一个元素为基准。
3. 第二层循环，以第一层循环的第二个数开始，到未排序的数组

#### 性能分析
1. 最坏时间复杂度 О(nlog n)
2. 最优时间复杂度 О(nlog n)
3. 平均时间复杂度 О(nlog n)
4. 空间复杂度   О(n)

### 堆排序

#### 背景知识
1. 你得掌握完全二叉树的知识
2. 分得清最大和最小堆是如何构建的。假设我们规定，数组末尾的元素大小来定义最大或者最小堆。
3. 二叉树中在数组的下标算法
```
1. 数组下标i的左子节点在位置  (2*i+1)
2. 数组下标i的右节点在位置    (2*i+2)
3. 数组下标i的父节点在位置    floor(i-1)/2
```
4. 了解先序遍历的方式，从根元素开始访问，再访问左节点，再到右结点。

#### 实现思路
1. 首先你得调整当前元素为二叉树的表现形式，即调整对应的位置。
2. 每个元素跟对应的父节点对比大小即可。

#### [代码实现](./HeapSort.php)

##### 方案1
以最大堆为例
1. 找到父节点的位置，先序遍历，从定点的父节点开始访问，父节点下标计算，floor($count / 2) - 1
2. 先创建一个最小堆，这时，堆可能只满足完全二叉树的性质，但排序并不正确。
3. 然后再对堆进行排序。
```
1. 25,47,94,97,42,65,94,70,26,52
初始化为完全二叉树
              25
            /   \
           /     \
          47      94
         / \     / \
        /   \   /   \
        97   42 65   94
       / \  /
      70 26 52

1. 建堆（最小堆，父节点是当前节点中最小的数）
25,26,65,47,42,94,94,70,97,52
              25
            /   \
           /     \
          26     65
         / \     / \
        /   \   /   \
        47   42 94   94
       / \  /
      70 97 52
2. 排序
第一次就把最小的数，置换到数组末尾了。
 i 9 52,26,65,47,42,94,94,70,97,25
 i 8 97,42,65,47,52,94,94,70,26,25
 i 7 97,47,65,70,52,94,94,42,26,25
 i 6 94,52,65,70,97,94,47,42,26,25
 i 5 94,70,65,94,97,52,47,42,26,25
 i 4 97,70,94,94,65,52,47,42,26,25
 i 3 97,94,94,70,65,52,47,42,26,25
 i 2 94,97,94,70,65,52,47,42,26,25
 i 1 97,94,94,70,65,52,47,42,26,25
 i 0 97,94,94,70,65,52,47,42,26,25

```

#### 性能分析
1. 最坏时间复杂度 О(nlog n)
2. 最优时间复杂度 О(nlog n)
3. 平均时间复杂度 О(nlog n)
4. 空间复杂度   О(n)
