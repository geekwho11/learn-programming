## 排序算法

### 冒泡排序

#### 背景知识

#### 实现思路
1. 采用2个指针，循环对比两个数的大小。
2. 注意循环的结束，条件，外层结束条件是数组的个数。
3. 内层循环 可以从前或者后面进行对比，重点，遇到小的元素，交换位置，移动到前面的位置。

#### [代码实现](./BubbleSort.php)

##### 方案1
1. 外层循环，倒序循环，到第一个元素结束。
2. 内层的循环，前后两个元素对比，最小的数，移动到最前面的位置。

##### 方案2
1. 外层循环，从第一个元素开始计算
2. 内层倒序开始循环，从最后一个元素开始对比，如果比前一个元素小，就交换位置。

#### 性能分析

1. 时间复杂度为O(n^2)，其中n为元素的个数
2. 最好情况时间复杂度为O(n)，刚好数组已排序。
3. 最坏情况时间复杂度为O(n^2)

### 快速排序

#### 背景知识

#### 实现思路
1. 主要采用2分法实现。

#### [代码实现](./QuickSort.php)

##### 方案1
1. 注意循环结束条件
2. 快排的主要思想就是2分法，取一个中间值，将比中间值大和小的值分组。
3. 然后递归调用，直到触发循环结束条件。

#### 性能分析

1. 时间复杂度为O(nlogn)，其中n为元素的个数
2. 最好情况时间复杂度为O(logn)，每次都恰好五五分。
3. 最坏情况时间复杂度为O(n^2),可能情况是一边是一个，一边是n-1个，即一个已经排好序的数组。

#### 参考链接
1. [如何证明快速排序法的平均复杂度为 O(nlogn)](https://www.zhihu.com/question/22393997)

### 选择排序

#### 背景知识

#### 实现思路
1. 在未排序的数组里，指定第一个元素，循环找到比这个数小的，交换位置。
2. 然后再在剩下的元素继续寻找最小的数，放在当前已排序的末尾。

#### [代码实现](./SelectSort.php)

##### 方案1
1. 外层循环
2. 内层循环，以第一个数为标准。
3. 找到比第一个还小的数，进行交换。

#### 性能分析

1. 最坏时间复杂度 О(n²)
2. 最优时间复杂度 О(n²)
3. 平均时间复杂度 О(n²)
4. 最坏空间复杂度 О(n) total, O(1) auxiliary
